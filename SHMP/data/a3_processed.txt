computer
science
pronounced
star
listen
computer
algorithm
widely
used
pathfinding
graph
traversal
process
plotting
efficiently
traversable
path
point
called
node
Noted
performance
accuracy
enjoys
widespread
use
However
practical
travel
routing
system
generally
outperformed
algorithm
pre
process
graph
attain
better
performance
although
work
found
superior
approach
Peter
Hart
Nils
Nilsson
Bertram
Raphael
Stanford
Research
Institute
SRI
International
first
described
algorithm
1968
extension
Edsger
Dijkstra
1959
algorithm
achieves
better
time
performance
using
heuristic
us
best
first
search
find
least
cost
path
given
initial
node
one
goal
node
one
possible
goal
traverse
graph
follows
path
lowest
expected
total
cost
distance
keeping
sorted
priority
queue
alternate
path
segment
along
way
us
knowledge
plus
heuristic
cost
function
node
x
usually
denoted
f
determine
order
search
visit
node
tree
cost
function
sum
two
function
past
path
cost
function
known
distance
starting
node
current
node
x
usually
denoted
g
future
path
cost
function
admissible
heuristic
estimate
distance
x
goal
usually
denoted
h
h
part
f
function
must
admissible
heuristic
must
overestimate
distance
goal
Thus
application
like
routing
h
might
represent
straight
line
distance
goal
since
physically
smallest
possible
distance
two
point
node
heuristic
h
satisfies
additional
condition
every
edge
y
graph
d
denotes
length
edge
h
called
monotone
consistent
case
implemented
efficientlyroughly
speaking
node
need
processed
see
closed
set
equivalent
running
Dijkstra
algorithm
reduced
cost
d
y
d
y
h
h
1968
Nils
Nilsson
suggested
heuristic
approach
Shakey
Robot
navigate
room
containing
obstacle
path
finding
algorithm
called
A1
faster
version
best
known
formal
approach
Dijkstra
algorithm
finding
shortest
path
graph
Bertram
Raphael
suggested
significant
improvement
upon
algorithm
calling
revised
version
A2
Peter
E
Hart
introduced
argument
established
A2
minor
change
best
possible
algorithm
finding
shortest
path
Hart
Nilsson
Raphael
jointly
developed
proof
revised
A2
algorithm
optimal
finding
shortest
path
certain
well
defined
condition
Like
informed
search
algorithm
first
search
route
appear
likely
lead
towards
goal
set
apart
greedy
best
first
search
also
take
distance
already
traveled
account
g
part
heuristic
cost
starting
point
simply
local
cost
previously
expanded
node
Starting
initial
node
maintains
priority
queue
node
traversed
known
open
set
fringe
lower
f
given
node
x
higher
priority
step
algorithm
node
lowest
f
value
removed
queue
f
g
value
neighbor
updated
accordingly
neighbor
added
queue
algorithm
continues
goal
node
lower
f
value
node
queue
queue
empty
Goal
node
may
passed
multiple
time
remain
node
lower
f
value
may
lead
shorter
path
goal
f
value
goal
length
shortest
path
since
h
goal
zero
admissible
heuristic
algorithm
described
far
give
u
length
shortest
path
find
actual
sequence
step
algorithm
easily
revised
node
path
keep
track
predecessor
algorithm
run
ending
node
point
predecessor
node
predecessor
start
node
Additionally
heuristic
monotonic
consistent
see
closed
set
node
already
traversed
may
used
make
search
efficient
following
pseudocode
describes
algorithm
dubious
discus
function
start
goal
closedset
empty
set
set
node
already
evaluated
openset
start
set
tentative
node
evaluated
initially
containing
start
node
came_from
empty
map
map
navigated
node
g_score
start
0
Cost
start
along
best
known
path
Estimated
total
cost
start
goal
y
f_score
start
g_score
start
heuristic_cost_estimate
start
goal
openset
empty
current
node
openset
lowest
f_score
value
current
goal
return
reconstruct_path
came_from
goal
remove
current
openset
add
current
closedset
neighbor
neighbor_nodes
current
neighbor
closedset
continue
tentative_g_score
g_score
current
dist_between
current
neighbor
neighbor
openset
tentative_g_score
g_score
neighbor
came_from
neighbor
current
g_score
neighbor
tentative_g_score
f_score
neighbor
g_score
neighbor
heuristic_cost_estimate
neighbor
goal
neighbor
openset
add
neighbor
openset
return
failure
function
reconstruct_path
came_from
current
total_path
current
current
came_from
current
came_from
current
total_path
append
current
return
total_path
Remark
pseudocode
assumes
heuristic
function
monotonic
consistent
see
frequent
case
many
practical
problem
Shortest
Distance
Path
road
network
However
assumption
true
node
closed
set
may
rediscovered
cost
improved
word
closed
set
omitted
yielding
tree
search
algorithm
solution
guaranteed
exist
algorithm
adapted
new
node
added
open
set
lower
f
value
previous
iteration
Illustration
search
finding
path
start
node
goal
node
robot
motion
planning
problem
empty
circle
represent
node
open
set
remain
explored
filled
one
closed
set
Color
closed
node
indicates
distance
start
greener
farther
One
first
see
moving
straight
line
direction
goal
hitting
obstacle
explores
alternative
route
node
open
set
See
also
Dijkstra
algorithm
example
star
algorithm
action
node
city
connected
road
h
straight
line
distance
target
point
Key
green
start
blue
goal
orange
visited
algorithm
also
real
world
application
example
edge
railroad
h
great
circle
distance
shortest
possible
distance
sphere
target
algorithm
searching
path
Washington
D
Los
Angeles
Like
breadth
first
search
complete
always
find
solution
one
exists
heuristic
function
h
admissible
meaning
never
overestimate
actual
minimal
cost
reaching
goal
admissible
optimal
use
closed
set
closed
set
used
h
must
also
monotonic
consistent
optimal
mean
pair
adjacent
node
x
y
d
denotes
length
edge
must
ensures
path
X
initial
node
x
L
function
denotes
length
path
Y
path
X
extended
include
y
word
impossible
decrease
total
distance
far
estimated
remaining
distance
extending
path
include
neighboring
node
analogous
restriction
nonnegative
edge
weight
Dijkstra
algorithm
Monotonicity
implies
admissibility
heuristic
estimate
goal
node
zero
since
letting
P
v1
v2
vn
shortest
path
node
f
nearest
goal
g
also
optimally
efficient
heuristic
h
meaning
optimal
algorithm
employing
heuristic
expand
fewer
node
except
multiple
partial
solution
h
exactly
predicts
cost
optimal
path
Even
case
graph
exists
order
breaking
tie
priority
queue
examines
fewest
possible
node
Dijkstra
algorithm
another
example
uniform
cost
search
algorithm
viewed
special
case
h
0
x
General
depth
first
search
implemented
using
considering
global
counter
C
initialized
large
value
Every
time
process
node
assign
C
newly
discovered
neighbor
single
assignment
decrease
counter
C
one
Thus
earlier
node
discovered
higher
h
value
noted
however
Dijkstra
algorithm
depth
first
search
implemented
efficiently
without
including
h
value
node
number
simple
optimization
implementation
detail
significantly
affect
performance
implementation
first
detail
note
way
priority
queue
handle
tie
significant
effect
performance
situation
tie
broken
queue
behaves
LIFO
manner
behave
like
depth
first
search
among
equal
cost
path
avoiding
exploring
one
equally
optimal
solution
path
required
end
search
common
keep
node
reference
node
parent
end
search
reference
used
recover
optimal
path
reference
kept
important
node
doesn
appear
priority
queue
entry
corresponding
different
path
node
different
cost
standard
approach
check
node
added
already
appears
priority
queue
priority
parent
pointer
changed
correspond
lower
cost
path
standard
binary
heap
based
priority
queue
directly
support
operation
searching
one
element
augmented
hash
table
map
element
position
heap
allowing
decrease
priority
operation
performed
logarithmic
time
Alternatively
Fibonacci
heap
perform
decrease
priority
operation
constant
amortized
time
admissible
considers
fewer
node
admissible
search
algorithm
heuristic
us
optimistic
estimate
cost
path
every
node
considersoptimistic
true
cost
path
node
goal
least
great
estimate
critically
far
know
optimistic
estimate
might
achievable
main
idea
proof
terminates
search
found
path
whose
actual
cost
lower
estimated
cost
path
open
node
since
estimate
optimistic
safely
ignore
node
word
never
overlook
possibility
lower
cost
path
admissible
Suppose
search
algorithm
B
terminates
search
path
whose
actual
cost
le
estimated
cost
path
open
node
Based
heuristic
information
Algorithm
B
cannot
rule
possibility
path
node
lower
cost
B
might
consider
fewer
node
cannot
admissible
Accordingly
considers
fewest
node
admissible
search
algorithm
true
us
admissible
heuristic
Otherwise
guaranteed
expand
fewer
node
another
search
algorithm
heuristic
solves
one
search
problem
rather
series
similar
search
problem
Otherwise
guaranteed
expand
fewer
node
incremental
heuristic
search
algorithm
admissibility
criterion
guarantee
optimal
solution
path
also
mean
must
examine
equally
meritorious
path
find
optimal
path
possible
speed
search
expense
optimality
relaxing
admissibility
criterion
Oftentimes
want
bound
relaxation
guarantee
solution
path
worse
1
time
optimal
solution
path
new
guarantee
referred
admissible
number
admissible
algorithm
Weighted
ha
admissible
heuristic
function
weighted
version
search
one
us
hw
ha
1
heuristic
function
perform
search
usual
eventually
happens
faster
using
ha
since
fewer
node
expanded
path
hence
found
search
algorithm
cost
time
least
cost
path
graph
Static
Weighting
us
cost
function
f
g
1
Dynamic
Weighting
10
us
cost
function
f
g
1
w
d
depth
search
N
anticipated
length
solution
path
Sampled
Dynamic
Weighting
11
us
sampling
node
better
estimate
debias
heuristic
error
12
us
two
heuristic
function
first
FOCAL
list
used
select
candidate
node
second
hF
used
select
promising
node
FOCAL
list
13
selects
node
function
f
B
hF
B
constant
node
selected
algorithm
backtrack
function
C
f
D
hF
C
D
constant
AlphA
14
attempt
promote
depth
first
exploitation
preferring
recently
expanded
node
AlphA
us
cost
function
f
1
w
f
constant
parent
n
recently
expanded
node
time
complexity
depends
heuristic
worst
case
unbounded
search
space
number
node
expanded
exponential
length
solution
shortest
path
d
b
branching
factor
average
number
successor
per
state
15
assumes
goal
state
exists
reachable
start
state
state
space
infinite
algorithm
terminate
time
complexity
polynomial
search
space
tree
single
goal
state
heuristic
function
h
meet
following
condition
h
optimal
heuristic
exact
cost
get
x
goal
word
error
h
grow
faster
logarithm
perfect
heuristic
h
return
true
distance
x
goal
15
commonly
used
common
pathfinding
problem
application
game
originally
designed
general
graph
traversal
algorithm
find
application
diverse
problem
including
problem
parsing
using
stochastic
grammar
NLP
16
adapted
bidirectional
search
algorithm
Special
care
need
taken
stopping
criterion
17
Dijkstra
algorithm
uninformed
special
case
node
angle
path
planning
search
path
limited
move
along
graph
edge
rather
take
angle
Koenig
Sven
Maxim
Likhachev
Yaxin
Liu
David
Furcy
2004
Incremental
heuristic
search
AI
AI
Magazine
25
99112
Pohl
Ira
1970
First
result
effect
error
heuristic
search
Machine
Intelligence
5
219236
Pohl
Ira
August
1973
avoidance
relative
catastrophe
heuristic
competence
genuine
dynamic
weighting
computational
issue
heuristic
problem
solving
Proceedings
Third
International
Joint
Conference
Artificial
Intelligence
IJCAI
73
3
California
USA
pp
1117
Kll
Andreas
Hermann
Kaindl
August
1992
new
approach
dynamic
weighting
Proceedings
Tenth
European
Conference
Artificial
Intelligence
ECAI
92
Vienna
Austria
pp
1617
Ghallab
Malik
Dennis
Allard
August
1983
efficient
near
admissible
heuristic
search
algorithm
Proceedings
Eighth
International
Joint
Conference
Artificial
Intelligence
IJCAI
83
2
Karlsruhe
Germany
pp
789791
Reese
Bjrn
1999
AlphA
admissible
heuristic
search
algorithm
Klein
Dan
Manning
Christopher
D
2003
parsing
fast
exact
Viterbi
parse
selection
Proc
NAACL
HLT
Hart
P
E
Nilsson
N
J
Raphael
B
1972
Correction
Formal
Basis
Heuristic
Determination
Minimum
Cost
Paths
SIGART
Newsletter
37
2829
doi
10
1145
1056777
1056779
Nilsson
N
J
1980
Principles
Artificial
Intelligence
Palo
Alto
California
Tioga
Publishing
Company
ISBN0
935382
01
